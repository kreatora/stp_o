{
  "version": 3,
  "sources": ["../../tinyqueue/index.js", "../../polylabel/polylabel.js"],
  "sourcesContent": ["\nexport default class TinyQueue {\n    constructor(data = [], compare = (a, b) => (a < b ? -1 : a > b ? 1 : 0)) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this._up(this.length++);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n\n        if (--this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let bestChild = (pos << 1) + 1; // initially it is the left child\n            const right = bestChild + 1;\n\n            if (right < this.length && compare(data[right], data[bestChild]) < 0) {\n                bestChild = right;\n            }\n            if (compare(data[bestChild], item) >= 0) break;\n\n            data[pos] = data[bestChild];\n            pos = bestChild;\n        }\n\n        data[pos] = item;\n    }\n}\n", "\nimport Queue from 'tinyqueue';\n\nexport default function polylabel(polygon, precision = 1.0, debug = false) {\n    // find the bounding box of the outer ring\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for (const [x, y] of polygon[0]) {\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const cellSize = Math.max(precision, Math.min(width, height));\n\n    if (cellSize === precision) {\n        const result = [minX, minY];\n        result.distance = 0;\n        return result;\n    }\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    const cellQueue = new Queue([], (a, b) => b.max - a.max);\n\n    // take centroid as the first best guess\n    let bestCell = getCentroidCell(polygon);\n\n    // second guess: bounding box centroid\n    const bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    let numProbes = 2;\n\n    function potentiallyQueue(x, y, h) {\n        const cell = new Cell(x, y, h, polygon);\n        numProbes++;\n        if (cell.max > bestCell.d + precision) cellQueue.push(cell);\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log(`found best ${Math.round(1e4 * cell.d) / 1e4} after ${numProbes} probes`);\n        }\n    }\n\n    // cover polygon with initial cells\n    let h = cellSize / 2;\n    for (let x = minX; x < maxX; x += cellSize) {\n        for (let y = minY; y < maxY; y += cellSize) {\n            potentiallyQueue(x + h, y + h, h);\n        }\n    }\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        const {max, x, y, h: ch} = cellQueue.pop();\n\n        // do not drill down further if there's no chance of a better solution\n        if (max - bestCell.d <= precision) break;\n\n        // split the cell into four cells\n        h = ch / 2;\n        potentiallyQueue(x - h, y - h, h);\n        potentiallyQueue(x + h, y - h, h);\n        potentiallyQueue(x - h, y + h, h);\n        potentiallyQueue(x + h, y + h, h);\n    }\n\n    if (debug) {\n        console.log(`num probes: ${numProbes}\\nbest distance: ${bestCell.d}`);\n    }\n\n    const result = [bestCell.x, bestCell.y];\n    result.distance = bestCell.d;\n    return result;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    let inside = false;\n    let minDistSq = Infinity;\n\n    for (const ring of polygon) {\n        for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            const a = ring[i];\n            const b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    let area = 0;\n    let x = 0;\n    let y = 0;\n    const points = polygon[0];\n\n    for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        const a = points[i];\n        const b = points[j];\n        const f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    const centroid = new Cell(x / area, y / area, 0, polygon);\n    if (area === 0 || centroid.d < 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return centroid;\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n    let x = a[0];\n    let y = a[1];\n    let dx = b[0] - x;\n    let dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n        const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n"],
  "mappings": "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",
  "names": ["result", "h"]
}
